\newcommand{\tr}{\textsc{Tree Reconstruction}\xspace}
\newcommand{\tc}{\textsc{3COL}\xspace}

\section*{Problem 4}

We will describe a reduction from \tc to \tr. For this reduction we
will define gadgets for every vertex and edge in the input \tc graph
$G$, by creating one tree for every vertex and one tree for every
edge, which are described by Figure \ref{q4:vertextree}
and Figure \ref{q4:edgetree}.
In addition we will create a single scaffolding tree, which is
described by Figure \ref{q4:scafftree}. Finally, in this
reduction we will set the value of $m$ to be $H + 4n + 4$,
where $n$ is the number vertices in $G$, and $H$ corresponds
to the constant appearing in the tree gadgets, which is assumed
to be very large (greater than $4n + 4$).

This reduction is clearly polynomial time becasue the size of
each tree is linear in $n$, and the number of trees is at worst
quadratic in $n$. In order to prove that this reduction is correct,
we need to argue that a graph $G$ is 3-colorable if and only if there
is a tree $T$ with at most $m$ vertices that has all the gadget trees
as subtrees. 

For the forward direction, suppose $G$ is 3-colorable. We will
describe how to create a tree $T$ of size $m$ with all the gadget
trees as subtrees. First we initialize $T$ as the scaffolding
tree $T_S$, and we arbitrarily label the colors in a 3-coloring
of $G$ as $R$, $G$, and $B$. Now we will extend this tree
by adding a new node for every vertex $v_i$. Suppose the color
of $v_i$ is $C$: we will create a new node $c_i$ and
add an edge from node $v_i^C$ to $c_i$.

Now we argue that this $T$ has the desired properties.
First of all, $T_S$ had $H + 3n + 4$ nodes, and we 
added $n$ nodes to it to construct $T$, so clearly $T$
has exactly $m$ vertices.
Secondly, for each vertex $v_i$ in $G$ we attached a new node to
either $v_i^R$, $v_i^G$, or $v_i^B$ in $T_S$. Refer to the ``hat''
of the tree as node $R$ along with the $h_j$ nodes. Then
the subtree of $T$ corresponding to the hat, $c_i$, and
the $v$ nodes in the branch of the tree corresponding
ot the color of $v_i$ is isomorphic to the vertex gadget
of $v_i$. Thirdly, for every edge $(v_i, v_j)$ we know
that $v_i$ and $v_j$ have different colors in $G$, so
the $c_i$ and $c_j$ nodes must have been added in different
branches of $G$. Thus the subtree given by the hat, $c_i$,
$c_j$, and the $v$ nodes in the two branches corresponding to
the colors of $v_i$ and $v_j$ is isomorphic to the corresponding
edge gadget. Finally $T$ was constructed by extending $T_S$,
so $T_S$ is a subtree. Thus we have proved the forward
direction.

For the backwards direction of the proof, suppose we can
construct a tree $T$ with at most $m$ vertices containing
$T_S$ along with all the vertex and edge gadgets based on
$G$ as subtrees. We will argue from this that $G$ is 3-colorable.
First of all, given $T_S$ is a subtree $T$ must have at least
$H + 3n + 4$ vertices, so it can have at most $n$ vertices
in addition to the vertices in the subtree isomorphic to $T_S$.
Now we will consider the possible ways that $T_S$ could be
extended to $T$ in order to incorporate the vertex and
edge gadgets. Since $H$ is so large, the hats of the gadget
subtrees must be the same as the hat of $T_S$ (else we would
have to add too many vertices).
Each vertex gadget $v_i$ requires
a path of length $n$ rooted at $R$, with an extra vertex
attached to the $i$'th node in the path. Obviously the
only way to satisfy this for all $n$ gadgets given we can
only add $n$ extra nodes,
would be to attach exactly one new node to one
of the three $v_i^{color}$ vertices for each
$i \in \{1,\ldots,n\}$. Therefore we can conclude that $T$
must be isomorphic to $T_S$ with this kind of extension.

Given we know roughly the structure that $T$ must have,
we will argue how to 3-color $G$ based on $T$. First
locate the vertex of maximum degree and label it as $R$,
and label its leaf neighbours as $\{h_1,\ldots,h_H\}$
arbitrarily. Then arbitrarily label the three branches
corresponding to the remaining three children of as $R$,
$G$, and $B$, and label the depth $i$ non-leaf nodes
in each branch as $v_i^R$, $v_i^G$, and $v_i^B$
respectively. Given what we have reasoned about
the structure of $T$ this is possible to do, and for
each $i$ exactly one of $v_i^R$, $v_i^G$, or $v_i^B$
will have three neighbors. We color $v_i$ in $G$
with the label of the branch where the $v_i$ node
has three neighbors.

To complete the backwards direction of the proof, we
will argue that this satisfies the constraint that neighboring
vertices in $G$ must have different colors. Suppose $(v_i, v_j) \in E(G)$.
Then given the corresponding edge gadget it must be the case that
there is a degree 3 $v_i^*$ node in $T$ and a degree 3 $v_j^*$ node
in $T$ in separate branches. Therefore since we have argued that for each
$i$ there is a degree 3 node in exactly one branch of $T$ and this is
used to color the node, it must be the case that $v_i$ and $v_j$ are
assigned different colors.

Now we have established that \tc reduces to \tr, which implies
that \tr is in NP-HARD. All that remains in order to show that it is
in NP-COMPLETE is to prove that it is in NP. To see this we will
describe a polynomial-time verifier for ``yes'' instances of \tr.
The input string to the verifier will consist
of a reconstructed tree $T$ of
size at most $m$, along with isomorphism functions $\pi_i$ mapping every
node in each subtree $T_i$ to a node in $T$. Clearly this string
can be polynomial in length, as in the worst case the size of
an allowable $T$ is bounded above by the sum of all the subtree sizes,
and the size of each $\pi_i$ is at worst a constant multiple
of the size of each subtree. The verifier works by first counting
the number of nodes in $T$ to assert that it is less than $m$,
running DFS to assert that $T$ is in fact a tree, asserting that
each $\pi_i$ is a one-to-one function from $V(T_i)$ to $V(T)$,
and finally asserting that each $T_i$ is a subtree of $T$ one by one,
by asserting for every $(u, v) \in E(T_i)$ that
$(\pi_i(u), \pi_i(v)) \in E(T)$. This clearly runs in polynomial time, 
asserts that $T$ is a valid solution to the problem, and
cannot be fooled, as required.



\begin{figure}
\begin{tikzpicture}
  \node[shape=circle,draw=black] (R) at (0,0) {R};
  \node[shape=circle,draw=black] (h1) at (-1.5,2) {$h_0$};
  \node[shape=circle,draw=black] (h2) at (-0.5,2) {$h_1$};
  \node (dots) at (0.5,2) {$\ldots$};
  \node[shape=circle,draw=black] (hH) at (1.5,2) {$h_H$};
  \node[shape=circle,draw=black] (v1) at (0,-2) {$v_1$};
  \node[shape=circle,draw=black] (v2) at (0,-4) {$v_2$};
  \node (dots1) at (0,-5) {$\ldots$};
  \node[shape=circle,draw=black] (vi) at (0,-6) {$v_i$};
  \node[shape=circle,draw=black] (ci) at (2,-6) {$c_i$};
  \node (dots2) at (0,-7) {$\ldots$};
  \node[shape=circle,draw=black] (vn) at (0,-8) {$v_n$};
  \node[shape=circle,draw=black] (s) at (0,-10) {$s$};
  \path (R) edge node {} (h1);
  \path (R) edge node {} (h2);
  \path (R) edge node {} (hH);
  \path (R) edge node {} (v1);
  \path (v1) edge node {} (v2);
  \path (v2) edge node {} (dots1);
  \path (dots1) edge node {} (vi);
  \path (vi) edge node {} (ci);
  \path (vi) edge node {} (dots2);
  \path (dots2) edge node {} (vn);
  \path (vn) edge node {} (s);
\end{tikzpicture}
\caption{Vertex gadget tree $T_{v_i}$ in \tr reduction for vertex $v_i$.
         This contains $H + n + 3$ vertices.}
\label{q4:vertextree}
\end{figure}

\begin{figure}
\begin{tikzpicture}
  \node[shape=circle,draw=black] (R) at (0,0) {R};
  \node[shape=circle,draw=black] (h1) at (-1.5,2) {$h_0$};
  \node[shape=circle,draw=black] (h2) at (-0.5,2) {$h_1$};
  \node (dots) at (0.5,2) {$\ldots$};
  \node[shape=circle,draw=black] (hH) at (1.5,2) {$h_H$};
  \node[shape=circle,draw=black] (v11) at (-2,-2) {$v_1^{(1)}$};
  \node[shape=circle,draw=black] (v12) at (2,-2) {$v_1^{(2)}$};
  \node[shape=circle,draw=black] (v21) at (-2,-4) {$v_2^{(1)}$};
  \node[shape=circle,draw=black] (v22) at (2,-4) {$v_2^{(2)}$};
  \node (dots1) at (-2,-5) {$\ldots$};
  \node (dots2) at (2,-5) {$\ldots$};
  \node[shape=circle,draw=black] (vi1) at (-2,-6) {$v_i^{(1)}$};
  \node[shape=circle,draw=black] (vj2) at (2,-6) {$v_j^{(2)}$};
  \node[shape=circle,draw=black] (ci1) at (0,-6) {$c_i^{(1)}$};
  \node[shape=circle,draw=black] (ci2) at (4,-6) {$c_j^{(2)}$};
  \node (dots3) at (-2,-7) {$\ldots$};
  \node (dots4) at (2,-7) {$\ldots$};
  \node[shape=circle,draw=black] (vn1) at (-2,-8) {$v_n^{(1)}$};
  \node[shape=circle,draw=black] (vn2) at (2,-8) {$v_n^{(2)}$};
  \node[shape=circle,draw=black] (s1) at (-2,-10) {$s^{(1)}$};
  \node[shape=circle,draw=black] (s2) at (2,-10) {$s^{(2)}$};
  \path (R) edge node {} (h1);
  \path (R) edge node {} (h2);
  \path (R) edge node {} (hH);
  \path (R) edge node {} (v11);
  \path (R) edge node {} (v12);
  \path (v11) edge node {} (v21);
  \path (v12) edge node {} (v22);
  \path (v21) edge node {} (dots1);
  \path (v22) edge node {} (dots2);
  \path (dots1) edge node {} (vi1);
  \path (dots2) edge node {} (vj2);
  \path (vi1) edge node {} (ci1);
  \path (vj2) edge node {} (ci2);
  \path (vi1) edge node {} (dots3);
  \path (vj2) edge node {} (dots4);
  \path (dots3) edge node {} (vn1);
  \path (dots4) edge node {} (vn2);
  \path (vn1) edge node {} (s1);
  \path (vn2) edge node {} (s2);
\end{tikzpicture}
\caption{Edge gadget tree $T_{(v_i,v_j)}$ in \tr reduction for edge $(v_i, v_j)$. This contains
         $H + 2n + 5$ vertices.}
\label{q4:edgetree}
\end{figure}


\begin{figure}
\begin{tikzpicture}
  \node[shape=circle,draw=black] (R) at (0,0) {R};
  \node[shape=circle,draw=black] (h1) at (-1.5,2) {$h_0$};
  \node[shape=circle,draw=black] (h2) at (-0.5,2) {$h_1$};
  \node (dots) at (0.5,2) {$\ldots$};
  \node[shape=circle,draw=black] (hH) at (1.5,2) {$h_H$};
  \node[shape=circle,draw=black] (v1R) at (-3,-2) {$v_1^R$};
  \node[shape=circle,draw=black] (v1G) at (0,-2) {$v_1^G$};
  \node[shape=circle,draw=black] (v1B) at (3,-2) {$v_1^B$};
  \node[shape=circle,draw=black] (v2R) at (-3,-4) {$v_2^R$};
  \node[shape=circle,draw=black] (v2G) at (0,-4) {$v_2^G$};
  \node[shape=circle,draw=black] (v2B) at (3,-4) {$v_2^B$};
  \node[shape=circle,draw=black] (v3R) at (-3,-6) {$v_3^R$};
  \node[shape=circle,draw=black] (v3G) at (0,-6) {$v_3^G$};
  \node[shape=circle,draw=black] (v3B) at (3,-6) {$v_3^B$};
  \node (dotsR) at (-3,-7) {$\ldots$};
  \node (dotsG) at (0,-7) {$\ldots$};
  \node (dotsB) at (3,-7) {$\ldots$};
  \node[shape=circle,draw=black] (vnR) at (-3,-8) {$v_n^R$};
  \node[shape=circle,draw=black] (vnG) at (0,-8) {$v_n^G$};
  \node[shape=circle,draw=black] (vnB) at (3,-8) {$v_n^B$};
  \node[shape=circle,draw=black] (sR) at (-3,-10) {$s^R$};
  \node[shape=circle,draw=black] (sG) at (0,-10) {$s^G$};
  \node[shape=circle,draw=black] (sB) at (3,-10) {$s^B$};
  \path (R) edge node {} (h1);
  \path (R) edge node {} (h2);
  \path (R) edge node {} (hH);
  \path (R) edge node {} (v1R);
  \path (R) edge node {} (v1G);
  \path (R) edge node {} (v1B);
  \path (v1R) edge node {} (v2R);
  \path (v1G) edge node {} (v2G);
  \path (v1B) edge node {} (v2B);
  \path (v2R) edge node {} (v3R);
  \path (v2G) edge node {} (v3G);
  \path (v2B) edge node {} (v3B);
  \path (v3R) edge node {} (dotsR);
  \path (v3G) edge node {} (dotsG);
  \path (v3B) edge node {} (dotsB);
  \path (dotsR) edge node {} (vnR);
  \path (dotsG) edge node {} (vnG);
  \path (dotsB) edge node {} (vnB);
  \path (vnR) edge node {} (sR);
  \path (vnG) edge node {} (sG);
  \path (vnB) edge node {} (sB);
\end{tikzpicture}
\caption{Scaffolding tree $T_S$ in \tr reduction. This contains $H + 3n + 4$ vertices.}
\label{q4:scafftree}
\end{figure}
