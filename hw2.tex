\documentclass{article}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{algorithm, algpseudocode}
\usepackage{enumitem}
\newtheorem{lemma}{Lemma}

\author{Andrew Bennett, Richard Strong Bowen, Bhai Jaiveer Singh, Ivy Suiwen Wu}
\title{CS 6820 Problem Set 2}

\begin{document}
\maketitle

\section*{Problem 1}

In order to address this problem we will introduce a new directed graph $G^*$,
which contains all the vertices in $G$ as well as an additional source vertex $s$
and sink vertex $t$. For every edge $(u, v)$ in $G$ we introduce two directed
edges in $G^*$; one from $u$ to $v$ and one from $v$ to $u$. In addition we
introduce an edge from $s$ to every vertex from $V(G)$, and an edge from every
vertex from $V(G)$ to $t$. Finally we define capacities on these edges
as follows:

\[
c(u, v) =
    \begin{cases}
        m &\quad \text{if}\ u = s \\
        m + 2d - deg(u) &\quad \text{if}\ v = t \\
        1 &\quad \text{otherwise} \\
    \end{cases}
\]

Now, consider an arbitrary cut $(S, T)$ of the directed graph $G^*$. We will use the shorthand
$S' = S \setminus \{s\}$, and $T' = T \setminus \{t\}$, $V' = S' \cup T'$, and
$E' = \{(u, v) \mid (u, v) \in E(G^*),\ u \neq s,\ v \neq t\}$.
Furthermore, for every vertex $u \in V'$ we will define $k_{S'}(u)$, $k_{T'}(u)$, and $k_{V'}(u)$
to be the number of vertices in $S'$, $T'$, and $V'$ respectively that $u$ has a directed
edge to. Note that obviously for every vertex $k_{S'}(u) + k_{T'}(u) = k_{V'}(u)$.
The capacity of the cut is as follows:

\begin{align*}
  c(S, T) &= \sum_{u \in S'}{c(u, t)} + \sum_{v \in T'}{c(s, v)} + \sum_{u \in S',\ v \in T',\ (u, v) \in E'}{c(u, v)} \\
          &= \sum_{u \in S'}{(m + 2d - k_{V'}(u))} + \sum_{v \in T'}{m} + \sum_{u \in S',\ v \in T',\ (u, v) \in E'}{1} \\
          &= |S'|(m + 2d) - \sum_{u \in S'}{k_{V'}(u)} + |T'|m + \sum_{u \in S'}{k_{T'}(u)} \\
          &= |V'|m + 2|S'|d - \sum_{u \in S'}{k_{S'}(u)} \\
          &= |V'|m + 2|S'|d - 2|S'|D(S') \\ 
          &= |V'|m + 2|S'|(d - D(S')) \\ 
\end{align*}
where $m$ refers to the number of edges in the original graph $G$, and
$D(S')$ refers to the average degree of the vertices in the subgraph of $G$
defined by taking the vertices in $S'$, and all edges with both endpoints in $S'$.

Since $|V'|m$ is a constant for all cuts, the cut capacity will be minimized when
$|S'|(d - D(S'))$ is minimized. Furthermore, it is clear that the value of the cut
is less than $|V'|m$ if and only if the subgraph of $G$ defined by $S'$ has
average degree greater than $d$.

This gives a natural algorithm for finding a dense subgraph: run any max flow algorithm
on $G^*$ to calculate a maximum flow, and then compute a corresponding minimum
cut $c(S, T)$. If the value of the max flow / min cut is less than $|V'|m$ then $S'$ defines
a subgraph of $G$ with average degree greater than $d$. Otherwise no such dense subgraph
exists, because if there was one then it would give a smaller cut.

To analyze the running time of the algorithm, we need to specify the procedure used to
calculate the maximum flow and a corresponding minimum cut. For maximum flow calculation
we can use Dinitz's algorithm, which has a running time of $O(mn^2)$. For calculating
a minimum cut given this maximum flow, we calculate the residual graph $G^*_f$ using the
maximum flow $f$, and calculate the set $S'$ of all vertices reachable from $s$ in $G^*_f$.
As proven in lectures in the derivation of the max-flow min-cut theorem, this defines
a minimum cut. Calculating reachability can trivially be computed in $O(m + n)$. Therefore
the overall running time of our algorithm is polynomial.

\section*{Problem 2}

\subsection*{2a}
We can maintain an invariant that $c'$ is always $0-1$. The fact of this
invariant also preserves the $0-1$ property for $G_f$, because $\delta(P) = 1$,
that is, the update step can only take an edge, delete it, and add in its
reversal to the graph with capacity $1$. But, $\delta(P)$ being $1$ also
maintains the $c' \in \{0,1\}$ invariant for the same reason.

\subsection*{2b}

In the entire run of the blocking flow algortihm, the block of code that
augments $h$ using $P$ does at most $O(1)$ work per edge in the graph because
the entire path $P$ is deleted from $G'$. Each push onto the stack corresponds
to an edge and only a single time per edge. Each edge is deleted at most once
during the popping phase, and each vertex is deleted at most once.
Initialization is $O(m)$ for the reasons given in the notes. So, the total time
is $O(m+n) = O(m)$.

\subsection*{2c}

\begin{lemma} Let $G$ be a graph with $0-1$ capacities and $f$ a flow in $G$
such that $G_f$ is $0-1$. Let $f^*$ be a maximum, integral flow. Let $k=|f^*| -
|f|$.  Then $f^*-f$ has an $s$-$t$ path of length at most
$m/k$. \end{lemma}
\begin{proof}
Consider the augmenting flow $f^* - f$, which has value $k$. Since $f$ is
integral and there is an integral max flow, $f*-f$ is integral. Since $G'$ is
$0-1$, we have that $f^* - f$ has $k$ saturated edges out of $s$. Considering
$f^* - f$ as a sum of paths and cycles, we see that it can be decomposed
as $k$ paths prefixed by these $k$ saturated edges each with a flow of $1$
(plus possibly some cycles). Since $G'$
has maximum (residual) capacity $1$, no edge appears in two of these paths.
Therefore at least one of these paths must have no more than $m/k$ edges, or
else the union of the paths would have more than $m$ edges, giving a
contradiction.
\end{proof}

After the first $\sqrt{m}$ phases of Dinitz, the shortest augmenting path has length
$d(t) \geq \sqrt{m}$. This implies that $|f^*| - |f| \geq \sqrt{m}$, by the
contrapositive of the above lemma. Each
additional iteration increases the flow by at least 1, so there are at most
$\sqrt{m}$ more phases go to. Thus there are at most $2\sqrt{m}$ phases,
so number of phases is $O(\sqrt{m})$

\subsection*{2d}

Define $d(i)$ as the distance from $s$ to $i$ in $G_f$ and $D_j = \{v_i: d(i) = j \}$. 
\begin{lemma} Let $G$ be a graph with $0-1$ capacities, $f$ a flow in $G$ such that 
$G_f$ is $0-1$ and $d_t$ the distance from $s$ to $t$ in $G_f$. Only less than half 
of $\{D_i\}$ can have more than $2\cdot \frac{n}{d_t}$ vertices.\end{lemma}
\begin{proof}
By the end of each iteration, the cardinality of $\{D_i\}$ is always $d(t)$. 
If there are half or more $D_i$'s that has more than $2\frac{n}{d(t)}$ vertices, 
then $$\text{Total Vertices} \geq (2\frac{n}{d(t)} + 1) * \frac{1}{2} d(t) 
= n + \frac{1}{2} d(t) > n$$ which is a contradiction. 
\end{proof}

Suppose that Dinitz has run for $2n^{2/3}$ iterations; at this point the 
shortest path to $t$ has length $d(t)\geq 2n^{2/3}$. 
Given the above lemma, over half of the $\{D_i\}$ have fewer than
$n^{1/3}$ vertices, so it must be the case that there are two consecutive sets
($D_j$ and $D_{j+1}$) that have less than $n^{1/3}$ vertices each.
Clearly the number of edges crossing from $D_j$ to $D_{j+1}$ is less than $(n^{1/3})^2 = n^{2/3}$.
This defines an upper-bound on the min-cut of $G_f$, meaning that the flow
can be increased by at most $n^{2/3}$ at this point, so 
the algorithm can run at most another $n^{2/3}$ iterations. Thus the number
of phases is $O(n^{2/3})$.

\section*{Problem 3}

Let G = (V,E) denote the original graph and G' = (V,E') denote the graph with the k edges destroyed.
\begin{algorithm}[H]
\caption{}
\begin{algorithmic}[1]
\State Initialize C = \{\}
\While{$|C| < k$}
\State Find an s-t path P in G using BFS
\State Find the first unreachable node in P by using binary search with PING(v) as the comparator. Specifically, find the nodes u and v such that u is immediately before v in the s-t path and PING(v) returns no while PING(u) returns yes
\State Add $(u,v)$ to $C$
\State Delete edge $(u,v)$ from $G$
\EndWhile
\State Let R = \{\}
\State Use BFS on G, starting from the source, to find all nodes reachable from s. Add these to R
\State Return set of nodes U = V\textbackslash R
\end{algorithmic}
\end{algorithm}

There are only k iterations of the while loop. This is because of the min-cut
max-flow theorem: since we know that the max flow is k, the size of the min cut
must also be k. We are always deleting an edge from the min cut in each
iteration, since any s-t path must pass through the min cut and we are
specifically deleting the edge between the first unreachable node and its
predecessor, which must necessarily be on the min cut. Coversely, we also know
that any edge in the min cut must necessarily be on an s-t path because the
problem invariant states that each node in G is in an s-t path. Each iteration
breaks one or more s-t paths, and after deleting k edges we know there are no
more s-t paths in G, since the entire min cut has been destroyed. In each
iteration we use PING(v) $O(log n)$ times, because we are using it in a binary
search manner on a path of nodes with maximum length n. So this gives us a
total of $O(k log n)$ pings. All other operations such as BFS do not use PING(v)
so they are excluded from this analysis.

To show that the set of returned edges is indeed the set of unreachable edges,
we must first prove that the set of edges we deleted is the same as the
attacker. This is true because on every s-t path, we find the first node $v$ that
is unreachable, and delete the edge leading to it. This must be the same edge
as the attacker deleted because if it were any other edge, then either node $v$
would be reachable, or it be uncreachable but not the first unreachable node in
the path. Since we have deleted all of the same edges as the attacker, at the
end of the while loop, $G$ is disjointed with no s-t path lefts. This means that
all the nodes reachable from the source in our modified $G$ are the same as the
reachable nodes in G'.  Hence, when we run BFS in step 9, we correctly find all
the reachable nodes. We exclude these from $V$ to return $U$, the set of
unreachable nodes.

\section*{Problem 4}

\end{document}
